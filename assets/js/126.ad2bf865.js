(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{649:function(a,t,r){"use strict";r.r(t);var s=r(5),_=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"llm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#llm"}},[a._v("#")]),a._v(" LLM")]),a._v(" "),t("h2",{attrs:{id:"_1-딥러닝-모델-학습의-큰-흐름"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-딥러닝-모델-학습의-큰-흐름"}},[a._v("#")]),a._v(" 1. 딥러닝 모델 학습의 큰 흐름")]),a._v(" "),t("h3",{attrs:{id:"_1-1-전이-학습-transfer-learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-전이-학습-transfer-learning"}},[a._v("#")]),a._v(" 1.1 전이 학습 (Transfer Learning)")]),a._v(" "),t("p",[a._v("전이 학습은 이미 대규모 데이터로 학습된 모델의 능력을 다른 작업에 재사용하는 방법이다. 예를 들어, 인터넷 전체 텍스트로 학습된 언어 모델은 이미 문법, 어휘, 문맥 구조를 이해하고 있다. 이 모델을 처음부터 다시 학습시키는 대신, 기존 지식을 유지한 채 새로운 작업에 맞게 조금만 추가 학습하면 훨씬 적은 데이터로도 좋은 성능을 낼 수 있다. 현대 AI 대부분은 전이 학습을 기반으로 한다.")]),a._v(" "),t("h3",{attrs:{id:"_1-2-지도-미세-조정-supervised-fine-tuning-sft"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-지도-미세-조정-supervised-fine-tuning-sft"}},[a._v("#")]),a._v(" 1.2 지도 미세 조정 (Supervised Fine-Tuning, SFT)")]),a._v(" "),t("p",[a._v("SFT는 사전학습된 모델을 질문–응답 데이터로 다시 학습시키는 단계다. 사전학습만 된 모델은 문장을 자연스럽게 생성하지만, 사용자의 질문을 “의도대로” 따르지는 않는다. SFT에서는 사람이 만든 질문과 그에 대한 올바른 답변을 학습시켜, 모델이 지시를 이해하고 적절한 형식으로 응답하도록 만든다. 우리가 사용하는 챗봇이 말을 잘 듣는 이유가 바로 이 단계 덕분이다.")]),a._v(" "),t("h2",{attrs:{id:"_2-문장을-숫자로-이해하는-방법"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-문장을-숫자로-이해하는-방법"}},[a._v("#")]),a._v(" 2. 문장을 숫자로 이해하는 방법")]),a._v(" "),t("h3",{attrs:{id:"_2-1-임베딩-embedding"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-임베딩-embedding"}},[a._v("#")]),a._v(" 2.1 임베딩 (Embedding)")]),a._v(" "),t("p",[a._v("임베딩은 문장이나 단어를 의미를 담은 숫자 벡터로 변환하는 과정이다. 컴퓨터는 문장의 의미를 직접 이해하지 못하므로, 의미가 비슷한 문장은 비슷한 숫자 벡터가 되도록 학습한다. 예를 들어 “고양이”와 “강아지”는 벡터 공간에서 가깝고, “고양이”와 “자동차”는 멀다. 임베딩은 검색, 추천, 분류 등 거의 모든 AI 시스템의 기초가 된다.")]),a._v(" "),t("h3",{attrs:{id:"_2-2-대조-학습-contrastive-learning"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-대조-학습-contrastive-learning"}},[a._v("#")]),a._v(" 2.2 대조 학습 (Contrastive Learning)")]),a._v(" "),t("p",[a._v("대조 학습은 임베딩 모델을 학습시키는 핵심 방법이다. 관련 있는 문장 쌍은 벡터 공간에서 가깝게 만들고, 관련 없는 문장은 멀어지게 만든다. 예를 들어 질문과 정답 문장은 가까워지도록, 질문과 엉뚱한 문장은 멀어지도록 학습한다. 이 방식 덕분에 모델은 “의미적 유사성”을 잘 구분할 수 있게 된다.")]),a._v(" "),t("h2",{attrs:{id:"_3-검색의-기본-개념"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-검색의-기본-개념"}},[a._v("#")]),a._v(" 3. 검색의 기본 개념")]),a._v(" "),t("h3",{attrs:{id:"_3-1-키워드-검색과-bm25"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-키워드-검색과-bm25"}},[a._v("#")]),a._v(" 3.1 키워드 검색과 BM25")]),a._v(" "),t("p",[a._v("키워드 검색은 문서에 특정 단어가 얼마나 자주 등장하는지를 기준으로 검색하는 방식이다. BM25는 TF-IDF를 개선한 알고리즘으로, 단어 빈도뿐 아니라 문서 길이까지 고려해 점수를 계산한다. 구현이 단순하고 빠르며, 현재도 많은 검색 엔진에서 기본 검색 방식으로 사용된다. 단점은 단어가 다르면 의미가 같아도 찾기 어렵다는 점이다.")]),a._v(" "),t("h3",{attrs:{id:"_3-2-벡터-검색"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-벡터-검색"}},[a._v("#")]),a._v(" 3.2 벡터 검색")]),a._v(" "),t("p",[a._v("벡터 검색은 문서를 임베딩으로 변환한 뒤, 쿼리와 의미적으로 가까운 벡터를 찾는 방식이다. 같은 단어를 쓰지 않아도 의미가 비슷하면 검색된다. 예를 들어 “환불 방법”과 “결제 취소 절차”는 키워드는 다르지만 벡터 검색에서는 가깝다. 최근 AI 기반 검색과 RAG 시스템의 핵심 기술이다.")]),a._v(" "),t("h2",{attrs:{id:"_4-검색-성능을-높이는-방법"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-검색-성능을-높이는-방법"}},[a._v("#")]),a._v(" 4. 검색 성능을 높이는 방법")]),a._v(" "),t("h3",{attrs:{id:"_4-1-rrf-reciprocal-rank-fusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-rrf-reciprocal-rank-fusion"}},[a._v("#")]),a._v(" 4.1 RRF (Reciprocal Rank Fusion)")]),a._v(" "),t("p",[a._v("RRF는 여러 검색 결과를 하나로 합치는 방법이다. 각 검색 방식의 점수를 그대로 쓰지 않고, 순위를 기준으로 점수를 계산해 결합한다. 벡터 검색과 키워드 검색을 함께 사용할 때 자주 쓰이며, 한쪽에서만 강한 결과가 상위에 오르는 문제를 완화한다. 구현이 간단하면서도 성능이 안정적이다.")]),a._v(" "),t("h3",{attrs:{id:"_4-2-재정렬-re-ranking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-재정렬-re-ranking"}},[a._v("#")]),a._v(" 4.2 재정렬 (Re-ranking)")]),a._v(" "),t("p",[a._v("재정렬은 1차 검색 결과를 더 정밀한 모델로 다시 정렬하는 단계다. 처음부터 모든 문서를 정밀하게 평가하면 너무 느리기 때문에, 상위 몇 개 결과만 정확한 모델로 다시 평가한다. 검색 정확도를 크게 높일 수 있어 RAG 시스템에서 거의 필수로 사용된다.")]),a._v(" "),t("h3",{attrs:{id:"_4-3-교차-인코더-cross-encoder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-교차-인코더-cross-encoder"}},[a._v("#")]),a._v(" 4.3 교차 인코더 (Cross-Encoder)")]),a._v(" "),t("p",[a._v("교차 인코더는 쿼리와 문서를 동시에 입력으로 받아 직접 관련도를 계산한다. 문맥을 깊이 이해할 수 있어 정확도가 매우 높다. 하지만 모든 문서 쌍을 계산해야 하므로 속도가 느려 대규모 검색에는 적합하지 않다. 주로 재정렬 단계에서 사용된다.")]),a._v(" "),t("h2",{attrs:{id:"_5-인코더-구조의-차이"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-인코더-구조의-차이"}},[a._v("#")]),a._v(" 5. 인코더 구조의 차이")]),a._v(" "),t("h3",{attrs:{id:"_5-1-바이-인코더-bi-encoder"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-바이-인코더-bi-encoder"}},[a._v("#")]),a._v(" 5.1 바이 인코더 (Bi-Encoder)")]),a._v(" "),t("p",[a._v("바이 인코더는 쿼리와 문서를 각각 따로 임베딩한 뒤 벡터 유사도로 비교한다. 문서를 미리 임베딩해 저장할 수 있어 대규모 검색에 매우 효율적이다. 속도는 빠르지만 교차 인코더보다 정확도는 다소 낮다. 벡터 데이터베이스의 기본 구조다.")]),a._v(" "),t("h2",{attrs:{id:"_6-트랜스포머의-핵심-아이디어"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-트랜스포머의-핵심-아이디어"}},[a._v("#")]),a._v(" 6. 트랜스포머의 핵심 아이디어")]),a._v(" "),t("h3",{attrs:{id:"_6-1-셀프-어텐션-self-attention"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-셀프-어텐션-self-attention"}},[a._v("#")]),a._v(" 6.1 셀프 어텐션 (Self-Attention)")]),a._v(" "),t("p",[a._v("셀프 어텐션은 문장 안의 단어들이 서로 얼마나 관련 있는지를 계산하는 연산이다. 각 단어는 문맥에 따라 중요한 단어에 더 많은 가중치를 둔다. 이를 통해 모델은 단어 순서가 멀어도 관계를 파악할 수 있다. 트랜스포머의 성능을 결정하는 핵심 요소다.")]),a._v(" "),t("h3",{attrs:{id:"_6-2-트랜스포머-transformer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-트랜스포머-transformer"}},[a._v("#")]),a._v(" 6.2 트랜스포머 (Transformer)")]),a._v(" "),t("p",[a._v("트랜스포머는 2017년 구글이 발표한 모델 구조로, 셀프 어텐션을 기반으로 한다. RNN과 달리 이전 상태를 순차적으로 전달하지 않아 병렬 처리가 가능하다. 이 구조 덕분에 대규모 데이터 학습이 가능해졌고, 오늘날 LLM의 기반이 되었다.")]),a._v(" "),t("h2",{attrs:{id:"_7-어텐션-연산-최적화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-어텐션-연산-최적화"}},[a._v("#")]),a._v(" 7. 어텐션 연산 최적화")]),a._v(" "),t("h3",{attrs:{id:"_7-1-flash-attention"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-flash-attention"}},[a._v("#")]),a._v(" 7.1 Flash Attention")]),a._v(" "),t("p",[a._v("Flash Attention은 어텐션 연산을 블록 단위로 재구성해 GPU 메모리 접근을 최소화한다. 느린 HBM 접근을 줄이고 빠른 SRAM을 적극 활용해 속도와 메모리 효율을 동시에 개선한다. 모델 구조를 바꾸지 않고도 성능을 크게 높일 수 있다.")]),a._v(" "),t("h3",{attrs:{id:"_7-2-gqa-mqa"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-gqa-mqa"}},[a._v("#")]),a._v(" 7.2 GQA / MQA")]),a._v(" "),t("p",[a._v("GQA와 MQA는 Key와 Value 헤드를 여러 Query가 공유하도록 만든 구조다. KV 캐시 크기를 줄여 메모리 사용량을 크게 감소시킨다. 추론 성능은 유지하면서 더 큰 모델을 서비스할 수 있게 해주는 실용적인 기법이다.")]),a._v(" "),t("h2",{attrs:{id:"_8-추론-성능을-높이는-방법"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-추론-성능을-높이는-방법"}},[a._v("#")]),a._v(" 8. 추론 성능을 높이는 방법")]),a._v(" "),t("h3",{attrs:{id:"_8-1-연속-배치-continuous-batching"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-연속-배치-continuous-batching"}},[a._v("#")]),a._v(" 8.1 연속 배치 (Continuous Batching)")]),a._v(" "),t("p",[a._v("연속 배치는 추론 중 종료된 요청을 즉시 제거하고 새로운 요청을 추가하는 방식이다. 기존 배치 방식의 비효율을 해결해 GPU 사용률을 극대화한다. 대규모 LLM 서비스에서 필수적인 기술이다.")]),a._v(" "),t("h3",{attrs:{id:"_8-2-추측-디코딩-speculative-decoding"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-추측-디코딩-speculative-decoding"}},[a._v("#")]),a._v(" 8.2 추측 디코딩 (Speculative Decoding)")]),a._v(" "),t("p",[a._v("추측 디코딩은 작은 모델이 여러 토큰을 빠르게 예측하고, 큰 모델이 이를 검증하는 방식이다. 정확도는 유지하면서 추론 속도를 크게 높일 수 있다. 최근 고성능 LLM 서버에서 적극적으로 활용된다.")]),a._v(" "),t("h2",{attrs:{id:"_9-캐시와-메모리-관리"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-캐시와-메모리-관리"}},[a._v("#")]),a._v(" 9. 캐시와 메모리 관리")]),a._v(" "),t("h3",{attrs:{id:"_9-1-kv-캐시와-paged-attention"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-kv-캐시와-paged-attention"}},[a._v("#")]),a._v(" 9.1 KV 캐시와 Paged Attention")]),a._v(" "),t("p",[a._v("KV 캐시는 이전 토큰의 Key와 Value를 저장해 재계산을 피하는 방식이다. Paged Attention은 이를 블록 단위로 관리해 GPU 메모리를 효율적으로 사용한다. 긴 문장 생성에 필수적인 기술이다.")]),a._v(" "),t("h3",{attrs:{id:"_9-2-llm-캐시"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-llm-캐시"}},[a._v("#")]),a._v(" 9.2 LLM 캐시")]),a._v(" "),t("p",[a._v("LLM 캐시는 이전 요청과 응답을 저장해 동일하거나 유사한 요청이 들어오면 그대로 반환한다. 비용과 지연 시간을 줄이는 데 매우 효과적이다. 실서비스에서는 거의 반드시 사용된다.")]),a._v(" "),t("h2",{attrs:{id:"_10-인간-선호와-안전성"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-인간-선호와-안전성"}},[a._v("#")]),a._v(" 10. 인간 선호와 안전성")]),a._v(" "),t("h3",{attrs:{id:"_10-1-dpo-direct-preference-optimization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-dpo-direct-preference-optimization"}},[a._v("#")]),a._v(" 10.1 DPO (Direct Preference Optimization)")]),a._v(" "),t("p",[a._v("DPO는 사람이 더 선호하는 응답을 직접 학습하는 방식이다. 보상 모델 없이도 선호를 반영할 수 있어 RLHF보다 단순하고 안정적이다. 최신 LLM 학습에서 주목받고 있다.")]),a._v(" "),t("h3",{attrs:{id:"_10-2-llm-가드레일-guardrails"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-llm-가드레일-guardrails"}},[a._v("#")]),a._v(" 10.2 LLM 가드레일 (Guardrails)")]),a._v(" "),t("p",[a._v("가드레일은 모델 출력이나 검색 결과를 검사해 부적절한 내용을 차단한다. 개인정보 보호, 정책 준수, 안전한 서비스 운영을 위해 필수적인 구성 요소다.")]),a._v(" "),t("h2",{attrs:{id:"_11-생성-모델의-확장"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-생성-모델의-확장"}},[a._v("#")]),a._v(" 11. 생성 모델의 확장")]),a._v(" "),t("h3",{attrs:{id:"_11-1-디퓨전-모델-diffusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-1-디퓨전-모델-diffusion"}},[a._v("#")]),a._v(" 11.1 디퓨전 모델 (Diffusion)")]),a._v(" "),t("p",[a._v("디퓨전 모델은 노이즈에서 시작해 점진적으로 노이즈를 제거하며 이미지를 생성한다. 안정적이고 고품질의 이미지 생성이 가능해 현재 이미지 생성 모델의 주류다.")]),a._v(" "),t("h2",{attrs:{id:"_12-자주-혼동되는-개념"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-자주-혼동되는-개념"}},[a._v("#")]),a._v(" 12. 자주 혼동되는 개념")]),a._v(" "),t("h3",{attrs:{id:"_12-1-임베딩-vs-양자화"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-임베딩-vs-양자화"}},[a._v("#")]),a._v(" 12.1 임베딩 vs 양자화")]),a._v(" "),t("p",[a._v("임베딩은 데이터를 의미 벡터로 바꾸는 과정이다. 양자화는 모델의 수치 정밀도를 낮춰 가볍게 만드는 최적화 기법이다. 목적과 적용 단계가 완전히 다르다.")]),a._v(" "),t("h3",{attrs:{id:"_12-2-llm-vs-멀티모달-llm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-llm-vs-멀티모달-llm"}},[a._v("#")]),a._v(" 12.2 LLM vs 멀티모달 LLM")]),a._v(" "),t("p",[a._v("LLM은 텍스트 중심 모델이다. 이미지나 음성을 함께 처리하면 멀티모달 LLM이라 부른다. 입력 데이터의 종류가 기준이다.")])])}),[],!1,null,null,null);t.default=_.exports}}]);